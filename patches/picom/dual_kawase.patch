diff --git a/CONTRIBUTORS b/CONTRIBUTORS
index 03ac9e7..5649bdb 100644
--- a/CONTRIBUTORS
+++ b/CONTRIBUTORS
@@ -5,6 +5,7 @@ Adam Jackson <ajax@nwnk.net>
 Alexander Kapshuna <kapsh@kap.sh>
 Antonin DÃ©cimo <antonin.decimo@gmail.com>
 Avi-D-coder <avi.the.coder@gmail.com>
+Bernd Busse <tryone144@bussenet.de>
 Brottweiler <tibell.christoffer@gmail.com>
 Carl Worth <cworth@cworth.org>
 Christopher Jeffrey <chjjeffrey@gmail.com>
diff --git a/README.md b/README.md
index 264a531..d78db6c 100644
--- a/README.md
+++ b/README.md
@@ -3,6 +3,10 @@ picom
 
 **This is a development branch, bugs to be expected**
 
+**[WIP] Merge-branch for the *dual_kawase* blur shader**
+
+This branch includes a new blur method: The fast and good-looking *dual-filter kawase blur*! Use it with `--blur-method dual_kawase` and configure it with `--blur-strength LEVEL`. Only works with `--experimental-backends` and `--backend glx`!
+
 This is forked from the original Compton because it seems to have become unmaintained.
 
 The current battle plan of this fork is to refactor it to make the code _possible_ to maintain, so potential contributors won't be scared away when they take a look at the code.
diff --git a/man/picom.1.asciidoc b/man/picom.1.asciidoc
index 7f37009..9fe3b95 100644
--- a/man/picom.1.asciidoc
+++ b/man/picom.1.asciidoc
@@ -166,7 +166,7 @@ OPTIONS
 *--detect-client-leader*::
 	Use 'WM_CLIENT_LEADER' to group windows, and consider windows in the same group focused at the same time. 'WM_TRANSIENT_FOR' has higher priority if *--detect-transient* is enabled, too.
 
-*--blur-method*, *--blur-size*, *--blur-deviation*::
+*--blur-method*, *--blur-size*, *--blur-deviation*, *--blur-strength*::
 	Parameters for background blurring, see the *BLUR* section for more information.
 
 *--blur-background*::
@@ -397,8 +397,8 @@ Available options of the 'blur' section are: ::
 
   *method*:::
     A string. Controls the blur method. Corresponds to the *--blur-method* command line option. Available choices are:
-      'none' to disable blurring; 'gaussian' for gaussian blur; 'box' for box blur; 'kernel' for convolution blur with a custom kernel.
-    Note: 'gaussian' and 'box' blur methods are only supported by the experimental backends.
+      'none' to disable blurring; 'gaussian' for gaussian blur; 'box' for box blur; 'kernel' for convolution blur with a custom kernel; 'dual_kawase' for dual-filter kawase blur.
+    Note: 'gaussian', 'box' and 'dual_kawase' blur methods are only supported by the experimental backends.
     (default: none)
 
   *size*:::
@@ -407,6 +407,9 @@ Available options of the 'blur' section are: ::
   *deviation*:::
     A floating point number. The standard deviation for the 'gaussian' blur method. Corresponds to the *--blur-deviation* command line option (default: 0.84089642).
 
+  *strength*:::
+    An integer in the range 1-20. The strength of the 'dual_kawase' blur method. Corresponds to the *--blur-strength* command line option. If not specified, the value requested by *--blur-size* is approximated (default: 5).
+
   *kernel*:::
     A string. The kernel to use for the 'kernel' blur method, specified in the same format as the *--blur-kerns* option. Corresponds to the *--blur-kerns* command line option.
 
diff --git a/src/backend/backend.c b/src/backend/backend.c
index f03e1ff..83dbce3 100644
--- a/src/backend/backend.c
+++ b/src/backend/backend.c
@@ -211,6 +211,9 @@ void paint_all_new(session_t *ps, struct managed_win *t, bool ignore_damage) {
 				// fading out.
 				blur_opacity =
 				    w->opacity / win_calc_opacity_target(ps, w, true);
+			} else if (!ps->o.blur_background_fixed) {
+				// Apply blur intensity depending on the window opacity.
+				blur_opacity = w->opacity;
 			}
 
 			if (real_win_mode == WMODE_TRANS || ps->o.force_win_blend) {
diff --git a/src/backend/backend.h b/src/backend/backend.h
index 5a18e0a..7c36f9b 100644
--- a/src/backend/backend.h
+++ b/src/backend/backend.h
@@ -65,6 +65,11 @@ struct kernel_blur_args {
 	int kernel_count;
 };
 
+struct dual_kawase_blur_args {
+	int size;
+	int strength;
+};
+
 struct backend_operations {
 	// ===========    Initialization    ===========
 
diff --git a/src/backend/backend_common.c b/src/backend/backend_common.c
index 471a677..38c9f57 100644
--- a/src/backend/backend_common.c
+++ b/src/backend/backend_common.c
@@ -362,6 +362,98 @@ struct conv **generate_blur_kernel(enum blur_method method, void *args, int *ker
 	return NULL;
 }
 
+/// Generate kernel parameters for dual-kawase blur method. Falls back on approximating
+/// standard gauss radius if strength is not supplied
+struct dual_kawase_params *generate_dual_kawase_params(void *args) {
+	struct dual_kawase_blur_args *blur_args = args;
+	static const struct {
+		int iterations;
+		float offset;
+	} strength_levels[20] = {
+	    {.iterations = 1, .offset = 1.25f},        // LVL  1 => radius   4
+	    {.iterations = 1, .offset = 2.25f},        // LVL  2 => radius   7
+	    {.iterations = 2, .offset = 2.00f},        // LVL  3 => radius  14
+	    {.iterations = 2, .offset = 3.00f},        // LVL  4 => radius  20
+	    {.iterations = 2, .offset = 4.25f},        // LVL  5 => radius  28
+	    {.iterations = 3, .offset = 2.50f},        // LVL  6 => radius  35
+	    {.iterations = 3, .offset = 3.25f},        // LVL  7 => radius  45
+	    {.iterations = 3, .offset = 4.25f},        // LVL  8 => radius  57
+	    {.iterations = 3, .offset = 5.50f},        // LVL  9 => radius  74
+	    {.iterations = 4, .offset = 3.25f},        // LVL 10 => radius  91
+	    {.iterations = 4, .offset = 4.00f},        // LVL 11 => radius 110
+	    {.iterations = 4, .offset = 5.00f},        // LVL 12 => radius 135
+	    {.iterations = 4, .offset = 6.00f},        // LVL 13 => radius 161
+	    {.iterations = 4, .offset = 7.25f},        // LVL 14 => radius 195
+	    {.iterations = 4, .offset = 8.25f},        // LVL 15 => radius 221
+	    {.iterations = 5, .offset = 4.50f},        // LVL 16 => radius 250
+	    {.iterations = 5, .offset = 5.25f},        // LVL 17 => radius 287
+	    {.iterations = 5, .offset = 6.25f},        // LVL 18 => radius 330
+	    {.iterations = 5, .offset = 7.25f},        // LVL 19 => radius 383
+	    {.iterations = 5, .offset = 8.50f},        // LVL 20 => radius >450
+	};
+
+	auto params = ccalloc(1, struct dual_kawase_params);
+	params->iterations = 0;
+	params->offset = 1.0f;
+
+	if (blur_args->strength <= 0 && blur_args->size) {
+		// approximate blur_strength with gaussian blur_radius
+		if (blur_args->size < 6) {
+			blur_args->strength = 1;
+		} else if (blur_args->size < 11) {
+			blur_args->strength = 2;
+		} else if (blur_args->size < 17) {
+			blur_args->strength = 3;
+		} else if (blur_args->size < 24) {
+			blur_args->strength = 4;
+		} else if (blur_args->size < 32) {
+			blur_args->strength = 5;
+		} else if (blur_args->size < 40) {
+			blur_args->strength = 6;
+		} else if (blur_args->size < 51) {
+			blur_args->strength = 7;
+		} else if (blur_args->size < 67) {
+			blur_args->strength = 8;
+		} else if (blur_args->size < 83) {
+			blur_args->strength = 9;
+		} else if (blur_args->size < 101) {
+			blur_args->strength = 10;
+		} else if (blur_args->size < 123) {
+			blur_args->strength = 11;
+		} else if (blur_args->size < 148) {
+			blur_args->strength = 12;
+		} else if (blur_args->size < 177) {
+			blur_args->strength = 13;
+		} else if (blur_args->size < 208) {
+			blur_args->strength = 14;
+		} else if (blur_args->size < 236) {
+			blur_args->strength = 15;
+		} else if (blur_args->size < 269) {
+			blur_args->strength = 16;
+		} else if (blur_args->size < 309) {
+			blur_args->strength = 17;
+		} else if (blur_args->size < 357) {
+			blur_args->strength = 18;
+		} else if (blur_args->size < 417) {
+			blur_args->strength = 19;
+		} else {
+			blur_args->strength = 20;
+		}
+	}
+
+	if (blur_args->strength > 0) {
+		assert(blur_args->strength <= 20);
+		params->iterations = strength_levels[blur_args->strength - 1].iterations;
+		params->offset = strength_levels[blur_args->strength - 1].offset;
+	}
+
+	params->expand = 2 * (int)exp2f((float)params->iterations) *
+	                     (256 - (int)(256.0f - params->offset)) +
+	                 1;
+
+	return params;
+}
+
 void init_backend_base(struct backend_base *base, session_t *ps) {
 	base->c = ps->c;
 	base->loop = ps->loop;
diff --git a/src/backend/backend_common.h b/src/backend/backend_common.h
index 28048b1..ac885a9 100644
--- a/src/backend/backend_common.h
+++ b/src/backend/backend_common.h
@@ -16,6 +16,15 @@ typedef struct conv conv;
 typedef struct backend_base backend_t;
 struct backend_operations;
 
+struct dual_kawase_params {
+	/// Number of downsample passes
+	int iterations;
+	/// Pixel offset for down- and upsample
+	float offset;
+	/// Save area around blur target (@ref resize_width, @ref resize_height)
+	int expand;
+};
+
 bool build_shadow(xcb_connection_t *, xcb_drawable_t, double opacity, int width,
                   int height, const conv *kernel, xcb_render_picture_t shadow_pixel,
                   xcb_pixmap_t *pixmap, xcb_render_picture_t *pict);
@@ -41,3 +50,5 @@ default_backend_render_shadow(backend_t *backend_data, int width, int height,
 void init_backend_base(struct backend_base *base, session_t *ps);
 
 struct conv **generate_blur_kernel(enum blur_method method, void *args, int *kernel_count);
+
+struct dual_kawase_params *generate_dual_kawase_params(void *args);
diff --git a/src/backend/gl/gl_common.c b/src/backend/gl/gl_common.c
index b89c49e..af81792 100644
--- a/src/backend/gl/gl_common.c
+++ b/src/backend/gl/gl_common.c
@@ -35,11 +35,19 @@ struct gl_blur_context {
 	/// Temporary textures used for blurring. They are always the same size as the
 	/// target, so they are always big enough without resizing.
 	/// Turns out calling glTexImage to resize is expensive, so we avoid that.
-	GLuint blur_texture[2];
-	/// Temporary fbo used for blurring
-	GLuint blur_fbo;
+	GLuint *blur_textures;
+	/// Temporary fbos used for blurring
+	GLuint *blur_fbos;
+	/// Cached size of each blur_texture
+	struct texture_size {
+		int width;
+		int height;
+	} * texture_sizes;
 
-	int texture_width, texture_height;
+	int blur_texture_count;
+	int blur_fbo_count;
+
+	int fb_width, fb_height;
 
 	/// How much do we need to resize the damaged region for blurring.
 	int resize_width, resize_height;
@@ -538,51 +546,302 @@ void gl_compose(backend_t *base, void *image_data, int dst_x, int dst_y,
 /**
  * Blur contents in a particular region.
  */
+bool gl_kernel_blur(backend_t *base, double opacity, void *ctx, const rect_t *extent,
+                    const int width attr_unused, const int height attr_unused,
+                    const int nrects, const GLuint vao[2]) {
+	struct gl_blur_context *bctx = ctx;
+	struct gl_data *gd = (void *)base;
+
+	int dst_y_screen_coord = gd->height - extent->y2,
+	    dst_y_fb_coord = bctx->fb_height - extent->y2;
+
+	int curr = 0;
+	for (int i = 0; i < bctx->npasses; ++i) {
+		const gl_blur_shader_t *p = &bctx->blur_shader[i];
+		assert(p->prog);
+
+		assert(bctx->blur_textures[curr]);
+
+		// The origin to use when sampling from the source texture
+		GLint texorig_x, texorig_y;
+		GLuint src_texture;
+
+		if (i == 0) {
+			texorig_x = extent->x1;
+			texorig_y = dst_y_screen_coord;
+			src_texture = gd->back_texture;
+		} else {
+			texorig_x = extent->x1 + bctx->resize_width;
+			texorig_y = dst_y_fb_coord - bctx->resize_height;
+			src_texture = bctx->blur_textures[curr];
+		}
+
+		glBindTexture(GL_TEXTURE_2D, src_texture);
+		glUseProgram(p->prog);
+		if (i < bctx->npasses - 1) {
+			// not last pass, draw into framebuffer, with resized regions
+			glBindVertexArray(vao[1]);
+			glBindFramebuffer(GL_DRAW_FRAMEBUFFER, bctx->blur_fbos[0]);
+
+			glFramebufferTexture2D(GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
+			                       GL_TEXTURE_2D, bctx->blur_textures[!curr], 0);
+			glDrawBuffer(GL_COLOR_ATTACHMENT0);
+			if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) {
+				log_error("Framebuffer attachment failed.");
+				return false;
+			}
+
+			glUniform1f(p->unifm_opacity, 1.0);
+
+			glUniform2f(p->orig_loc, (GLfloat)bctx->resize_width,
+			            -(GLfloat)bctx->resize_height);
+			glViewport(0, 0, bctx->fb_width, bctx->fb_height);
+		} else {
+			// last pass, draw directly into the back buffer, with origin
+			// regions
+			glBindVertexArray(vao[0]);
+			glBindFramebuffer(GL_FRAMEBUFFER, gd->back_fbo);
+
+			glUniform1f(p->unifm_opacity, (float)opacity);
+
+			glUniform2f(p->orig_loc, 0, 0);
+			glViewport(0, 0, gd->width, gd->height);
+		}
+
+		glUniform2f(p->texorig_loc, (GLfloat)texorig_x, (GLfloat)texorig_y);
+		glDrawElements(GL_TRIANGLES, nrects * 6, GL_UNSIGNED_INT, NULL);
+
+		// XXX use multiple draw calls is probably going to be slow than
+		//     just simply blur the whole area.
+
+		curr = !curr;
+	}
+
+	return true;
+}
+
+bool gl_dual_kawase_blur(backend_t *base, double opacity, void *ctx, const rect_t *extent,
+                         const int width, const int height, const int nrects,
+                         const GLuint vao[2]) {
+	struct gl_blur_context *bctx = ctx;
+	struct gl_data *gd = (void *)base;
+
+	int dst_y_screen_coord = gd->height - extent->y2,
+	    dst_y_fb_coord = bctx->fb_height - extent->y2;
+
+	// Reduce number of iterations until the last one renders at least 1px in both
+	// dimensions
+	int iterations = bctx->blur_texture_count;
+	while (((width / (1 << iterations)) < 1 || (height / (1 << iterations)) < 1) &&
+	       iterations > 0) {
+		--iterations;
+	}
+
+	// Note: OpenGL matrices are column major
+	GLfloat projection_matrix[4][4] = {{2.0f / (GLfloat)bctx->fb_width, 0, 0, 0},
+	                                   {0, 2.0f / (GLfloat)bctx->fb_height, 0, 0},
+	                                   {0, 0, 0, 0},
+	                                   {-1, -1, 0, 1}};
+
+	// Kawase downsample pass
+	const gl_blur_shader_t *down_pass = &bctx->blur_shader[0];
+	assert(down_pass->prog);
+	glUseProgram(down_pass->prog);
+
+	// Update projection matrices in the blur shaders
+	glUniformMatrix4fv(down_pass->projection_loc, 1, false, projection_matrix[0]);
+	glUniform2f(down_pass->orig_loc, (GLfloat)bctx->resize_width,
+	            -(GLfloat)bctx->resize_height);
+
+	for (int i = 0; i < iterations; ++i) {
+		GLuint src_texture;
+		int tex_width, tex_height;
+		int texorig_x, texorig_y;
+
+		float halfpixel_x, halfpixel_y;
+
+		if (i == 0) {
+			// first pass: copy from back buffer
+			src_texture = gd->back_texture;
+			tex_width = gd->width;
+			tex_height = gd->height;
+
+			texorig_x = extent->x1;
+			texorig_y = dst_y_screen_coord;
+
+			halfpixel_x = 0.5f / (float)gd->width;
+			halfpixel_y = 0.5f / (float)gd->height;
+		} else {
+			// copy from previous pass
+			src_texture = bctx->blur_textures[i - 1];
+			tex_width = bctx->fb_width;
+			tex_height = bctx->fb_height;
+
+			texorig_x = extent->x1 + bctx->resize_width;
+			texorig_y = dst_y_fb_coord - bctx->resize_height;
+
+			auto src_size = bctx->texture_sizes[i - 1];
+			halfpixel_x = 0.5f / (float)src_size.width;
+			halfpixel_y = 0.5f / (float)src_size.height;
+		}
+
+		glBindTexture(GL_TEXTURE_2D, src_texture);
+		glBindVertexArray(vao[1]);
+		glBindFramebuffer(GL_DRAW_FRAMEBUFFER, bctx->blur_fbos[i]);
+		glDrawBuffer(GL_COLOR_ATTACHMENT0);
+
+		glUniform2f(down_pass->texorig_loc, (GLfloat)texorig_x, (GLfloat)texorig_y);
+		glUniform2f(down_pass->unifm_texture_size, (GLfloat)tex_width,
+		            (GLfloat)tex_height);
+		glUniform2f(down_pass->unifm_halfpixel, halfpixel_x, halfpixel_y);
+
+		auto tgt_size = bctx->texture_sizes[i];
+		glViewport(0, 0, tgt_size.width, tgt_size.height);
+		glDrawElements(GL_TRIANGLES, nrects * 6, GL_UNSIGNED_INT, NULL);
+	}
+
+	// Kawase upsample pass
+	const gl_blur_shader_t *up_pass = &bctx->blur_shader[1];
+	assert(up_pass->prog);
+	glUseProgram(up_pass->prog);
+
+	// Update projection matrices in the blur shaders
+	glUniformMatrix4fv(up_pass->projection_loc, 1, false, projection_matrix[0]);
+
+	glUniform2f(up_pass->texorig_loc, (GLfloat)(extent->x1 + bctx->resize_width),
+	            (GLfloat)(dst_y_fb_coord - bctx->resize_height));
+	glUniform2f(up_pass->unifm_texture_size, (GLfloat)bctx->fb_width,
+	            (GLfloat)bctx->fb_height);
+
+	for (int i = iterations - 1; i >= 0; --i) {
+		const GLuint src_texture = bctx->blur_textures[i];
+		int orig_x, orig_y;
+
+		auto src_size = bctx->texture_sizes[i];
+		float halfpixel_x = 0.5f / (float)src_size.width,
+		      halfpixel_y = 0.5f / (float)src_size.height;
+
+		int vp_width, vp_height;
+
+		glBindTexture(GL_TEXTURE_2D, src_texture);
+		if (i > 0) {
+			// not last pass, draw into next framebuffer
+			glBindVertexArray(vao[1]);
+			glBindFramebuffer(GL_DRAW_FRAMEBUFFER, bctx->blur_fbos[i - 1]);
+			glDrawBuffer(GL_COLOR_ATTACHMENT0);
+			glClearBufferiv(GL_COLOR, 0, (GLint[4]){255, 0, 0, 255});
+
+			orig_x = bctx->resize_width;
+			orig_y = -bctx->resize_height;
+
+			auto tgt_size = bctx->texture_sizes[i - 1];
+			vp_width = tgt_size.width;
+			vp_height = tgt_size.height;
+
+			glUniform1f(up_pass->unifm_opacity, (GLfloat)1);
+		} else {
+			// last pass, draw directly into the back buffer
+			glBindVertexArray(vao[0]);
+			glBindFramebuffer(GL_FRAMEBUFFER, gd->back_fbo);
+
+			// Update projection matrix
+			projection_matrix[0][0] = 2.0f / (GLfloat)gd->width;
+			projection_matrix[1][1] = 2.0f / (GLfloat)gd->height;
+			glUniformMatrix4fv(up_pass->projection_loc, 1, false,
+			                   projection_matrix[0]);
+
+			orig_x = 0;
+			orig_y = 0;
+
+			vp_width = gd->width;
+			vp_height = gd->height;
+
+			glUniform1f(up_pass->unifm_opacity, (GLfloat)opacity);
+		}
+
+		glUniform2f(up_pass->orig_loc, (GLfloat)orig_x, (GLfloat)orig_y);
+		glUniform2f(up_pass->unifm_halfpixel, halfpixel_x, halfpixel_y);
+
+		glViewport(0, 0, vp_width, vp_height);
+		glDrawElements(GL_TRIANGLES, nrects * 6, GL_UNSIGNED_INT, NULL);
+	}
+
+	return true;
+}
+
 bool gl_blur(backend_t *base, double opacity, void *ctx, const region_t *reg_blur,
              const region_t *reg_visible attr_unused) {
 	struct gl_blur_context *bctx = ctx;
 	auto gd = (struct gl_data *)base;
 
-	if (gd->width + bctx->resize_width * 2 != bctx->texture_width ||
-	    gd->height + bctx->resize_height * 2 != bctx->texture_height) {
+	bool ret = false;
+
+	if (gd->width + bctx->resize_width * 2 != bctx->fb_width ||
+	    gd->height + bctx->resize_height * 2 != bctx->fb_height) {
 		// Resize the temporary textures used for blur in case the root
 		// size changed
-		bctx->texture_width = gd->width + bctx->resize_width * 2;
-		bctx->texture_height = gd->height + bctx->resize_height * 2;
-
-		glBindTexture(GL_TEXTURE_2D, bctx->blur_texture[0]);
-		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, bctx->texture_width,
-		             bctx->texture_height, 0, GL_BGRA, GL_UNSIGNED_BYTE, NULL);
-		glBindTexture(GL_TEXTURE_2D, bctx->blur_texture[1]);
-		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, bctx->texture_width,
-		             bctx->texture_height, 0, GL_BGRA, GL_UNSIGNED_BYTE, NULL);
-
-		// XXX: do we need projection matrix for blur at all?
-		// Note: OpenGL matrices are column major
-		GLfloat projection_matrix[4][4] = {
-		    {2.0f / (GLfloat)bctx->texture_width, 0, 0, 0},
-		    {0, 2.0f / (GLfloat)bctx->texture_height, 0, 0},
-		    {0, 0, 0, 0},
-		    {-1, -1, 0, 1}};
-
-		// Update projection matrices in the blur shaders
-		for (int i = 0; i < bctx->npasses - 1; i++) {
-			assert(bctx->blur_shader[i].prog);
-			glUseProgram(bctx->blur_shader[i].prog);
-			int pml = glGetUniformLocationChecked(bctx->blur_shader[i].prog,
-			                                      "projection");
-			glUniformMatrix4fv(pml, 1, false, projection_matrix[0]);
-		}
+		bctx->fb_width = gd->width + bctx->resize_width * 2;
+		bctx->fb_height = gd->height + bctx->resize_height * 2;
+
+		if (bctx->method == BLUR_METHOD_DUAL_KAWASE) {
+			// Use smaller textures for each iteration
+			for (int i = 0; i < bctx->blur_texture_count; ++i) {
+				auto tex_size = bctx->texture_sizes + i;
+				tex_size->width = 1 + (bctx->fb_width - 1) / (1 << (i + 1));
+				tex_size->height = 1 + (bctx->fb_height - 1) / (1 << (i + 1));
+
+				glBindTexture(GL_TEXTURE_2D, bctx->blur_textures[i]);
+				glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, tex_size->width,
+				             tex_size->height, 0, GL_BGRA,
+				             GL_UNSIGNED_BYTE, NULL);
+
+				// Attach texture to FBO target
+				glBindFramebuffer(GL_DRAW_FRAMEBUFFER, bctx->blur_fbos[i]);
+				glFramebufferTexture2D(GL_DRAW_FRAMEBUFFER,
+				                       GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D,
+				                       bctx->blur_textures[i], 0);
+				if (glCheckFramebufferStatus(GL_FRAMEBUFFER) !=
+				    GL_FRAMEBUFFER_COMPLETE) {
+					log_error("Framebuffer attachment failed.");
+					glBindFramebuffer(GL_FRAMEBUFFER, 0);
+					return false;
+				}
+			}
+			glBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0);
+		} else {
+			glBindTexture(GL_TEXTURE_2D, bctx->blur_textures[0]);
+			glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, bctx->fb_width,
+			             bctx->fb_height, 0, GL_BGRA, GL_UNSIGNED_BYTE, NULL);
+			glBindTexture(GL_TEXTURE_2D, bctx->blur_textures[1]);
+			glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, bctx->fb_width,
+			             bctx->fb_height, 0, GL_BGRA, GL_UNSIGNED_BYTE, NULL);
+
+			// XXX: do we need projection matrix for blur at all?
+			// Note: OpenGL matrices are column major
+			GLfloat projection_matrix[4][4] = {
+			    {2.0f / (GLfloat)bctx->fb_width, 0, 0, 0},
+			    {0, 2.0f / (GLfloat)bctx->fb_height, 0, 0},
+			    {0, 0, 0, 0},
+			    {-1, -1, 0, 1}};
+
+			// Update projection matrices in the blur shaders
+			for (int i = 0; i < bctx->npasses - 1; i++) {
+				assert(bctx->blur_shader[i].prog);
+				glUseProgram(bctx->blur_shader[i].prog);
+				glUniformMatrix4fv(bctx->blur_shader[i].projection_loc, 1,
+				                   false, projection_matrix[0]);
+			}
 
-		GLfloat projection_matrix2[4][4] = {{2.0f / (GLfloat)gd->width, 0, 0, 0},
-		                                    {0, 2.0f / (GLfloat)gd->height, 0, 0},
-		                                    {0, 0, 0, 0},
-		                                    {-1, -1, 0, 1}};
-		assert(bctx->blur_shader[bctx->npasses - 1].prog);
-		glUseProgram(bctx->blur_shader[bctx->npasses - 1].prog);
-		int pml = glGetUniformLocationChecked(
-		    bctx->blur_shader[bctx->npasses - 1].prog, "projection");
-		glUniformMatrix4fv(pml, 1, false, projection_matrix2[0]);
+			GLfloat projection_matrix2[4][4] = {
+			    {2.0f / (GLfloat)gd->width, 0, 0, 0},
+			    {0, 2.0f / (GLfloat)gd->height, 0, 0},
+			    {0, 0, 0, 0},
+			    {-1, -1, 0, 1}};
+			assert(bctx->blur_shader[bctx->npasses - 1].prog);
+			glUseProgram(bctx->blur_shader[bctx->npasses - 1].prog);
+			glUniformMatrix4fv(bctx->blur_shader[bctx->npasses - 1].projection_loc,
+			                   1, false, projection_matrix2[0]);
+		}
 	}
 
 	// Remainder: regions are in Xorg coordinates
@@ -591,13 +850,10 @@ bool gl_blur(backend_t *base, double opacity, void *ctx, const region_t *reg_blu
 	const rect_t *extent = pixman_region32_extents((region_t *)reg_blur),
 	             *extent_resized = pixman_region32_extents(&reg_blur_resized);
 	int width = extent->x2 - extent->x1, height = extent->y2 - extent->y1;
-	int dst_y_resized_screen_coord = gd->height - extent_resized->y2,
-	    dst_y_resized_fb_coord = bctx->texture_height - extent_resized->y2;
 	if (width == 0 || height == 0) {
 		return true;
 	}
 
-	bool ret = false;
 	int nrects, nrects_resized;
 	const rect_t *rects = pixman_region32_rectangles((region_t *)reg_blur, &nrects),
 	             *rects_resized =
@@ -609,13 +865,13 @@ bool gl_blur(backend_t *base, double opacity, void *ctx, const region_t *reg_blu
 	auto coord = ccalloc(nrects * 16, GLint);
 	auto indices = ccalloc(nrects * 6, GLuint);
 	x_rect_to_coords(nrects, rects, extent_resized->x1, extent_resized->y2,
-	                 bctx->texture_height, gd->height, false, coord, indices);
+	                 bctx->fb_height, gd->height, false, coord, indices);
 
 	auto coord_resized = ccalloc(nrects_resized * 16, GLint);
 	auto indices_resized = ccalloc(nrects_resized * 6, GLuint);
 	x_rect_to_coords(nrects_resized, rects_resized, extent_resized->x1,
-	                 extent_resized->y2, bctx->texture_height, bctx->texture_height,
-	                 false, coord_resized, indices_resized);
+	                 extent_resized->y2, bctx->fb_height, bctx->fb_height, false,
+	                 coord_resized, indices_resized);
 	pixman_region32_fini(&reg_blur_resized);
 
 	GLuint vao[2];
@@ -649,69 +905,14 @@ bool gl_blur(backend_t *base, double opacity, void *ctx, const region_t *reg_blu
 	glVertexAttribPointer(vert_in_texcoord_loc, 2, GL_INT, GL_FALSE,
 	                      sizeof(GLint) * 4, (void *)(sizeof(GLint) * 2));
 
-	int curr = 0;
-	for (int i = 0; i < bctx->npasses; ++i) {
-		const gl_blur_shader_t *p = &bctx->blur_shader[i];
-		assert(p->prog);
-
-		assert(bctx->blur_texture[curr]);
-
-		// The origin to use when sampling from the source texture
-		GLint texorig_x, texorig_y;
-		GLuint src_texture;
-
-		if (i == 0) {
-			texorig_x = extent_resized->x1;
-			texorig_y = dst_y_resized_screen_coord;
-			src_texture = gd->back_texture;
-		} else {
-			texorig_x = 0;
-			texorig_y = 0;
-			src_texture = bctx->blur_texture[curr];
-		}
-
-		glBindTexture(GL_TEXTURE_2D, src_texture);
-		glUseProgram(p->prog);
-		if (i < bctx->npasses - 1) {
-			// not last pass, draw into framebuffer, with resized regions
-			glBindVertexArray(vao[1]);
-			glBindFramebuffer(GL_DRAW_FRAMEBUFFER, bctx->blur_fbo);
-
-			glFramebufferTexture2D(GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
-			                       GL_TEXTURE_2D, bctx->blur_texture[!curr], 0);
-			glDrawBuffer(GL_COLOR_ATTACHMENT0);
-			if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) {
-				log_error("Framebuffer attachment failed.");
-				goto end;
-			}
-			glUniform1f(p->unifm_opacity, 1.0);
-			// For other than last pass, we are drawing to a texture, we
-			// translate the render origin so we don't need a big texture
-			glUniform2f(p->orig_loc, -(GLfloat)extent_resized->x1,
-			            -(GLfloat)dst_y_resized_fb_coord);
-			glViewport(0, 0, bctx->texture_width, bctx->texture_height);
-		} else {
-			// last pass, draw directly into the back buffer, with origin
-			// regions
-			glBindVertexArray(vao[0]);
-			glBindFramebuffer(GL_FRAMEBUFFER, gd->back_fbo);
-			glUniform1f(p->unifm_opacity, (float)opacity);
-			glUniform2f(p->orig_loc, 0, 0);
-			glViewport(0, 0, gd->width, gd->height);
-		}
-
-		glUniform2f(p->texorig_loc, (GLfloat)texorig_x, (GLfloat)texorig_y);
-		glDrawElements(GL_TRIANGLES, nrects * 6, GL_UNSIGNED_INT, NULL);
-
-		// XXX use multiple draw calls is probably going to be slow than
-		//     just simply blur the whole area.
-
-		curr = !curr;
+	if (bctx->method == BLUR_METHOD_DUAL_KAWASE) {
+		ret = gl_dual_kawase_blur(base, opacity, ctx, extent_resized, width,
+		                          height, nrects, vao);
+	} else {
+		ret = gl_kernel_blur(base, opacity, ctx, extent_resized, width, height,
+		                     nrects, vao);
 	}
 
-	ret = true;
-
-end:
 	glBindFramebuffer(GL_FRAMEBUFFER, 0);
 	glBindTexture(GL_TEXTURE_2D, 0);
 	glBindBuffer(GL_ARRAY_BUFFER, 0);
@@ -719,6 +920,7 @@ end:
 	glDeleteBuffers(4, bo);
 	glBindVertexArray(0);
 	glDeleteVertexArrays(2, vao);
+	glUseProgram(0);
 
 	free(indices);
 	free(coord);
@@ -726,7 +928,6 @@ end:
 	free(coord_resized);
 
 	gl_check_err();
-
 	return ret;
 }
 
@@ -966,10 +1167,21 @@ void gl_destroy_blur_context(backend_t *base attr_unused, void *ctx) {
 	}
 	free(bctx->blur_shader);
 
-	glDeleteTextures(bctx->npasses > 1 ? 2 : 1, bctx->blur_texture);
-	if (bctx->npasses > 1) {
-		glDeleteFramebuffers(1, &bctx->blur_fbo);
+	if (bctx->blur_textures) {
+		glDeleteTextures(bctx->blur_texture_count, bctx->blur_textures);
+		free(bctx->blur_textures);
 	}
+	if (bctx->blur_fbos) {
+		glDeleteFramebuffers(bctx->blur_fbo_count, bctx->blur_fbos);
+		free(bctx->blur_fbos);
+	}
+	if (bctx->texture_sizes) {
+		free(bctx->texture_sizes);
+	}
+
+	bctx->blur_texture_count = 0;
+	bctx->blur_fbo_count = 0;
+
 	free(bctx);
 
 	gl_check_err();
@@ -978,17 +1190,11 @@ void gl_destroy_blur_context(backend_t *base attr_unused, void *ctx) {
 /**
  * Initialize GL blur filters.
  */
-void *gl_create_blur_context(backend_t *base, enum blur_method method, void *args) {
-	bool success = true;
-	auto gd = (struct gl_data *)base;
+bool gl_create_kernel_blur_context(void *blur_context, enum blur_method method, void *args) {
+	bool success;
 
+	struct gl_blur_context *ctx = blur_context;
 	struct conv **kernels;
-	auto ctx = ccalloc(1, struct gl_blur_context);
-
-	if (!method || method >= BLUR_METHOD_INVALID) {
-		ctx->method = BLUR_METHOD_NONE;
-		return ctx;
-	}
 
 	int nkernels;
 	ctx->method = BLUR_METHOD_KERNEL;
@@ -1001,7 +1207,7 @@ void *gl_create_blur_context(backend_t *base, enum blur_method method, void *arg
 
 	if (!nkernels) {
 		ctx->method = BLUR_METHOD_NONE;
-		return ctx;
+		return true;
 	}
 
 	ctx->blur_shader = ccalloc(max2(2, nkernels), gl_blur_shader_t);
@@ -1083,6 +1289,8 @@ void *gl_create_blur_context(backend_t *base, enum blur_method method, void *arg
 		pass->unifm_opacity = glGetUniformLocationChecked(pass->prog, "opacity");
 		pass->orig_loc = glGetUniformLocationChecked(pass->prog, "orig");
 		pass->texorig_loc = glGetUniformLocationChecked(pass->prog, "texorig");
+		pass->projection_loc =
+		    glGetUniformLocationChecked(pass->prog, "projection");
 		ctx->resize_width += kern->w / 2;
 		ctx->resize_height += kern->h / 2;
 	}
@@ -1095,27 +1303,18 @@ void *gl_create_blur_context(backend_t *base, enum blur_method method, void *arg
 		pass->unifm_opacity = -1;
 		pass->orig_loc = glGetUniformLocationChecked(pass->prog, "orig");
 		pass->texorig_loc = glGetUniformLocationChecked(pass->prog, "texorig");
+		pass->projection_loc =
+		    glGetUniformLocationChecked(pass->prog, "projection");
 		ctx->npasses = 2;
 	} else {
 		ctx->npasses = nkernels;
 	}
 
-	// Texture size will be defined by gl_blur
-	glGenTextures(2, ctx->blur_texture);
-	glBindTexture(GL_TEXTURE_2D, ctx->blur_texture[0]);
-	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
-	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
-	glBindTexture(GL_TEXTURE_2D, ctx->blur_texture[1]);
-	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
-	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
-	// Generate FBO and textures when needed
-	glGenFramebuffers(1, &ctx->blur_fbo);
-	if (!ctx->blur_fbo) {
-		log_error("Failed to generate framebuffer object for blur");
-		success = false;
-		goto out;
-	}
+	// Specify required textures and FBOs
+	ctx->blur_texture_count = 2;
+	ctx->blur_fbo_count = 1;
 
+	success = true;
 out:
 	if (method != BLUR_METHOD_KERNEL) {
 		// We generated the blur kernels, so we need to free them
@@ -1125,16 +1324,218 @@ out:
 		free(kernels);
 	}
 
+	free(extension);
+	// Restore LC_NUMERIC
+	setlocale(LC_NUMERIC, lc_numeric_old);
+	free(lc_numeric_old);
+
+	return success;
+}
+
+bool gl_create_dual_kawase_blur_context(void *blur_context, enum blur_method method,
+                                        void *args) {
+	bool success;
+	struct gl_blur_context *ctx = blur_context;
+
+	ctx->method = method;
+
+	auto blur_params = generate_dual_kawase_params(args);
+
+	// Specify required textures and FBOs
+	ctx->blur_texture_count = blur_params->iterations;
+	ctx->blur_fbo_count = blur_params->iterations;
+
+	ctx->resize_width += blur_params->expand;
+	ctx->resize_height += blur_params->expand;
+
+	ctx->npasses = 2;
+	ctx->blur_shader = ccalloc(ctx->npasses, gl_blur_shader_t);
+
+	char *lc_numeric_old = strdup(setlocale(LC_NUMERIC, NULL));
+	// Enforce LC_NUMERIC locale "C" here to make sure decimal point is sane
+	// Thanks to hiciu for reporting.
+	setlocale(LC_NUMERIC, "C");
+
+	// Dual-kawase downsample shader / program
+	auto down_pass = ctx->blur_shader;
+	{
+		// clang-format off
+		static const char *FRAG_SHADER_DOWN = GLSL(330,
+			uniform sampler2D tex_src;
+			uniform vec2 texture_size;
+			uniform vec2 halfpixel;
+			in vec2 texcoord;
+			out vec4 out_color;
+			void main() {
+				float offset = %.7g;
+				vec2 uv = texcoord / texture_size;
+				vec4 sum = texture2D(tex_src, uv) * 4.0;
+				sum += texture2D(tex_src, uv - halfpixel.xy * offset);
+				sum += texture2D(tex_src, uv + halfpixel.xy * offset);
+				sum += texture2D(tex_src, uv + vec2(halfpixel.x, -halfpixel.y) * offset);
+				sum += texture2D(tex_src, uv - vec2(halfpixel.x, -halfpixel.y) * offset);
+				out_color = sum / 8.0;
+			}
+		);
+		// clang-format on
+
+		// Build shader
+		size_t shader_len =
+		    strlen(FRAG_SHADER_DOWN) + 10 /* offset */ + 1 /* null terminator */;
+		char *shader_str = ccalloc(shader_len, char);
+		auto real_shader_len =
+		    snprintf(shader_str, shader_len, FRAG_SHADER_DOWN, blur_params->offset);
+		CHECK(real_shader_len >= 0);
+		CHECK((size_t)real_shader_len < shader_len);
+
+		// Build program
+		down_pass->prog = gl_create_program_from_str(vertex_shader, shader_str);
+		free(shader_str);
+		if (!down_pass->prog) {
+			log_error("Failed to create GLSL program.");
+			success = false;
+			goto out;
+		}
+		glBindFragDataLocation(down_pass->prog, 0, "out_color");
+
+		// Get uniform addresses
+		down_pass->unifm_texture_size =
+		    glGetUniformLocationChecked(down_pass->prog, "texture_size");
+		down_pass->unifm_halfpixel =
+		    glGetUniformLocationChecked(down_pass->prog, "halfpixel");
+		down_pass->orig_loc =
+		    glGetUniformLocationChecked(down_pass->prog, "orig");
+		down_pass->texorig_loc =
+		    glGetUniformLocationChecked(down_pass->prog, "texorig");
+		down_pass->projection_loc =
+		    glGetUniformLocationChecked(down_pass->prog, "projection");
+	}
+
+	// Dual-kawase upsample shader / program
+	auto up_pass = ctx->blur_shader + 1;
+	{
+		// clang-format off
+		static const char *FRAG_SHADER_UP = GLSL(330,
+			uniform sampler2D tex_src;
+			uniform vec2 texture_size;
+			uniform vec2 halfpixel;
+			uniform float offset;
+			uniform float opacity;
+			in vec2 texcoord;
+			out vec4 out_color;
+			void main() {
+				float offset = %.7g;
+				vec2 uv = texcoord / texture_size;
+				vec4 sum = texture2D(tex_src, uv + vec2(-halfpixel.x * 2.0, 0.0) * offset);
+				sum += texture2D(tex_src, uv + vec2(-halfpixel.x, halfpixel.y) * offset) * 2.0;
+				sum += texture2D(tex_src, uv + vec2(0.0, halfpixel.y * 2.0) * offset);
+				sum += texture2D(tex_src, uv + vec2(halfpixel.x, halfpixel.y) * offset) * 2.0;
+				sum += texture2D(tex_src, uv + vec2(halfpixel.x * 2.0, 0.0) * offset);
+				sum += texture2D(tex_src, uv + vec2(halfpixel.x, -halfpixel.y) * offset) * 2.0;
+				sum += texture2D(tex_src, uv + vec2(0.0, -halfpixel.y * 2.0) * offset);
+				sum += texture2D(tex_src, uv + vec2(-halfpixel.x, -halfpixel.y) * offset) * 2.0;
+				out_color = sum / 12.0 * opacity;
+			}
+		);
+		// clang-format on
+
+		// Build shader
+		size_t shader_len =
+		    strlen(FRAG_SHADER_UP) + 10 /* offset */ + 1 /* null terminator */;
+		char *shader_str = ccalloc(shader_len, char);
+		auto real_shader_len =
+		    snprintf(shader_str, shader_len, FRAG_SHADER_UP, blur_params->offset);
+		CHECK(real_shader_len >= 0);
+		CHECK((size_t)real_shader_len < shader_len);
+
+		// Build program
+		up_pass->prog = gl_create_program_from_str(vertex_shader, shader_str);
+		free(shader_str);
+		if (!up_pass->prog) {
+			log_error("Failed to create GLSL program.");
+			success = false;
+			goto out;
+		}
+		glBindFragDataLocation(up_pass->prog, 0, "out_color");
+
+		// Get uniform addresses
+		up_pass->unifm_opacity =
+		    glGetUniformLocationChecked(up_pass->prog, "opacity");
+		up_pass->unifm_texture_size =
+		    glGetUniformLocationChecked(up_pass->prog, "texture_size");
+		up_pass->unifm_halfpixel =
+		    glGetUniformLocationChecked(up_pass->prog, "halfpixel");
+		up_pass->orig_loc = glGetUniformLocationChecked(up_pass->prog, "orig");
+		up_pass->texorig_loc =
+		    glGetUniformLocationChecked(up_pass->prog, "texorig");
+		up_pass->projection_loc =
+		    glGetUniformLocationChecked(up_pass->prog, "projection");
+	}
+
+	success = true;
+out:
+	free(blur_params);
+
 	if (!success) {
-		gl_destroy_blur_context(&gd->base, ctx);
 		ctx = NULL;
 	}
 
-	free(extension);
 	// Restore LC_NUMERIC
 	setlocale(LC_NUMERIC, lc_numeric_old);
 	free(lc_numeric_old);
 
+	return success;
+}
+
+void *gl_create_blur_context(backend_t *base, enum blur_method method, void *args) {
+	bool success;
+	auto gd = (struct gl_data *)base;
+
+	auto ctx = ccalloc(1, struct gl_blur_context);
+
+	if (!method || method >= BLUR_METHOD_INVALID) {
+		ctx->method = BLUR_METHOD_NONE;
+		return ctx;
+	}
+
+	if (method == BLUR_METHOD_DUAL_KAWASE) {
+		success = gl_create_dual_kawase_blur_context(ctx, method, args);
+	} else {
+		success = gl_create_kernel_blur_context(ctx, method, args);
+	}
+	if (!success) {
+		goto out;
+	}
+
+	// Texture size will be defined by gl_blur
+	ctx->blur_textures = ccalloc(ctx->blur_texture_count, GLuint);
+	ctx->texture_sizes = ccalloc(ctx->blur_texture_count, struct texture_size);
+	glGenTextures(ctx->blur_texture_count, ctx->blur_textures);
+	for (int i = 0; i < ctx->blur_texture_count; ++i) {
+		glBindTexture(GL_TEXTURE_2D, ctx->blur_textures[i]);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+	}
+
+	// Generate FBO and textures when needed
+	ctx->blur_fbos = ccalloc(ctx->blur_fbo_count, GLuint);
+	glGenFramebuffers(ctx->blur_fbo_count, ctx->blur_fbos);
+	for (int i = 0; i < ctx->blur_fbo_count; ++i) {
+		if (!ctx->blur_fbos[i]) {
+			log_error("Failed to generate framebuffer object for blur");
+			success = false;
+			goto out;
+		}
+	}
+
+out:
+	if (!success) {
+		gl_destroy_blur_context(&gd->base, ctx);
+		ctx = NULL;
+	}
+
 	gl_check_err();
 	return ctx;
 }
@@ -1165,8 +1566,8 @@ const char *win_shader_glsl = GLSL(330,
 		vec3 rgb_brightness = texelFetch(brightness, ivec2(0, 0), 0).rgb;
 		// Ref: https://en.wikipedia.org/wiki/Relative_luminance
 		float brightness = rgb_brightness.r * 0.21 +
-		                   rgb_brightness.g * 0.72 +
-		                   rgb_brightness.b * 0.07;
+				   rgb_brightness.g * 0.72 +
+				   rgb_brightness.b * 0.07;
 		if (brightness > max_brightness)
 			c.rgb = c.rgb * (max_brightness / brightness);
 
@@ -1212,8 +1613,10 @@ bool gl_init(struct gl_data *gd, session_t *ps) {
 	}
 
 	glBindTexture(GL_TEXTURE_2D, gd->back_texture);
-	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
-	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
 	glBindTexture(GL_TEXTURE_2D, 0);
 
 	gl_win_shader_from_string(vertex_shader, win_shader_glsl, &gd->win_shader);
@@ -1384,9 +1787,9 @@ void gl_present(backend_t *base, const region_t *region) {
 		// clang-format off
 		memcpy(&coord[i * 8],
 		       (GLint[]){rect[i].x1, gd->height - rect[i].y2,
-		                 rect[i].x2, gd->height - rect[i].y2,
-		                 rect[i].x2, gd->height - rect[i].y1,
-		                 rect[i].x1, gd->height - rect[i].y1},
+				 rect[i].x2, gd->height - rect[i].y2,
+				 rect[i].x2, gd->height - rect[i].y1,
+				 rect[i].x1, gd->height - rect[i].y1},
 		       sizeof(GLint) * 8);
 		// clang-format on
 
diff --git a/src/backend/gl/gl_common.h b/src/backend/gl/gl_common.h
index 0a4ff49..fdeef47 100644
--- a/src/backend/gl/gl_common.h
+++ b/src/backend/gl/gl_common.h
@@ -33,8 +33,11 @@ typedef struct {
 typedef struct {
 	GLuint prog;
 	GLint unifm_opacity;
+	GLint unifm_texture_size;
+	GLint unifm_halfpixel;
 	GLint orig_loc;
 	GLint texorig_loc;
+	GLint projection_loc;
 } gl_blur_shader_t;
 
 typedef struct {
@@ -168,7 +171,8 @@ static inline void gl_check_err_(const char *func, int line) {
 }
 
 static inline void gl_clear_err(void) {
-	while (glGetError() != GL_NO_ERROR);
+	while (glGetError() != GL_NO_ERROR)
+		;
 }
 
 #define gl_check_err() gl_check_err_(__func__, __LINE__)
diff --git a/src/backend/xrender/xrender.c b/src/backend/xrender/xrender.c
index a44dbc1..dd50443 100644
--- a/src/backend/xrender/xrender.c
+++ b/src/backend/xrender/xrender.c
@@ -505,6 +505,12 @@ void *create_blur_context(backend_t *base attr_unused, enum blur_method method,
 		ret->method = BLUR_METHOD_NONE;
 		return ret;
 	}
+	if (method == BLUR_METHOD_DUAL_KAWASE) {
+		log_warn("Blur method 'dual_kawase' is not compatible with the 'xrender' "
+		         "backend.");
+		ret->method = BLUR_METHOD_NONE;
+		return ret;
+	}
 
 	ret->method = BLUR_METHOD_KERNEL;
 	struct conv **kernels;
diff --git a/src/config.c b/src/config.c
index a88bc02..6a44fbc 100644
--- a/src/config.c
+++ b/src/config.c
@@ -88,6 +88,8 @@ enum blur_method parse_blur_method(const char *src) {
 		return BLUR_METHOD_BOX;
 	} else if (strcmp(src, "gaussian") == 0) {
 		return BLUR_METHOD_GAUSSIAN;
+	} else if (strcmp(src, "dual_kawase") == 0) {
+		return BLUR_METHOD_DUAL_KAWASE;
 	} else if (strcmp(src, "none") == 0) {
 		return BLUR_METHOD_NONE;
 	}
@@ -542,6 +544,7 @@ char *parse_config(options_t *opt, const char *config_file, bool *shadow_enable,
 	    .blur_method = BLUR_METHOD_NONE,
 	    .blur_radius = 3,
 	    .blur_deviation = 0.84089642,
+	    .blur_strength = 5,
 	    .blur_background_frame = false,
 	    .blur_background_fixed = false,
 	    .blur_background_blacklist = NULL,
diff --git a/src/config.h b/src/config.h
index cd32add..217af84 100644
--- a/src/config.h
+++ b/src/config.h
@@ -60,6 +60,7 @@ enum blur_method {
 	BLUR_METHOD_KERNEL,
 	BLUR_METHOD_BOX,
 	BLUR_METHOD_GAUSSIAN,
+	BLUR_METHOD_DUAL_KAWASE,
 	BLUR_METHOD_INVALID,
 };
 
@@ -189,6 +190,8 @@ typedef struct options {
 	int blur_radius;
 	// Standard deviation for the gaussian blur
 	double blur_deviation;
+	// Strength of the dual_kawase blur
+	int blur_strength;
 	/// Whether to blur background when the window frame is not opaque.
 	/// Implies blur_background.
 	bool blur_background_frame;
diff --git a/src/config_libconfig.c b/src/config_libconfig.c
index b07155c..8d4a0f0 100644
--- a/src/config_libconfig.c
+++ b/src/config_libconfig.c
@@ -522,6 +522,8 @@ char *parse_config_libconfig(options_t *opt, const char *config_file, bool *shad
 	config_lookup_int(&cfg, "blur-size", &opt->blur_radius);
 	// --blur-deviation
 	config_lookup_float(&cfg, "blur-deviation", &opt->blur_deviation);
+	// --blur-strength
+	config_lookup_int(&cfg, "blur-strength", &opt->blur_strength);
 	// --blur-background
 	if (config_lookup_bool(&cfg, "blur-background", &ival) && ival) {
 		if (opt->blur_method == BLUR_METHOD_NONE) {
@@ -625,6 +627,11 @@ char *parse_config_libconfig(options_t *opt, const char *config_file, bool *shad
 		}
 
 		config_setting_lookup_int(blur_cfg, "size", &opt->blur_radius);
+		if (opt->blur_method == BLUR_METHOD_DUAL_KAWASE && opt->blur_radius > 500) {
+			log_warn("Blur radius >500 not supported by dual_kawase method, "
+			         "capping to 500.");
+			opt->blur_radius = 500;
+		}
 
 		if (config_setting_lookup_string(blur_cfg, "kernel", &sval)) {
 			opt->blur_kerns = parse_blur_kern_lst(sval, conv_kern_hasneg,
@@ -635,6 +642,12 @@ char *parse_config_libconfig(options_t *opt, const char *config_file, bool *shad
 		}
 
 		config_setting_lookup_float(blur_cfg, "deviation", &opt->blur_deviation);
+		config_setting_lookup_int(blur_cfg, "strength", &opt->blur_strength);
+		if (opt->blur_method == BLUR_METHOD_DUAL_KAWASE && opt->blur_strength > 20) {
+			log_warn("Blur strength >20 not supported by dual_kawase method, "
+			         "capping to 20.");
+			opt->blur_strength = 20;
+		}
 	}
 
 	// Wintype settings
diff --git a/src/options.c b/src/options.c
index 8f44b43..112d144 100644
--- a/src/options.c
+++ b/src/options.c
@@ -212,6 +212,9 @@ static void usage(const char *argv0, int ret) {
 	    "--blur-deviation\n"
 	    "  The standard deviation for the 'gaussian' blur method.\n"
 	    "\n"
+	    "--blur-strength\n"
+	    "  The strength level of the 'dual_kawase' blur method.\n"
+	    "\n"
 	    "--blur-background\n"
 	    "  Blur background of semi-transparent / ARGB windows. Bad in\n"
 	    "  performance. The switch name may change without prior\n"
@@ -437,6 +440,7 @@ static const struct option longopts[] = {
     {"blur-method", required_argument, NULL, 328},
     {"blur-size", required_argument, NULL, 329},
     {"blur-deviation", required_argument, NULL, 330},
+    {"blur-strength", required_argument, NULL, 331},
     {"experimental-backends", no_argument, NULL, 733},
     {"monitor-repaint", no_argument, NULL, 800},
     {"diagnostics", no_argument, NULL, 801},
@@ -841,6 +845,10 @@ bool get_cfg(options_t *opt, int argc, char *const *argv, bool shadow_enable,
 			// --blur-deviation
 			opt->blur_deviation = atof(optarg);
 			break;
+		case 331:
+			// --blur-strength
+			opt->blur_strength = atoi(optarg);
+			break;
 
 		P_CASEBOOL(733, experimental_backends);
 		P_CASEBOOL(800, monitor_repaint);
@@ -930,6 +938,20 @@ bool get_cfg(options_t *opt, int argc, char *const *argv, bool shadow_enable,
 		CHECK(opt->blur_kernel_count);
 	}
 
+	// Sanitize parameters for dual-filter kawase blur
+	if (opt->blur_method == BLUR_METHOD_DUAL_KAWASE) {
+		if (opt->blur_strength < 0 && opt->blur_radius > 500) {
+			log_warn("Blur radius >500 not supported by dual_kawase method, "
+			         "capping to 500.");
+			opt->blur_radius = 500;
+		}
+		if (opt->blur_strength > 20) {
+			log_warn("Blur strength >20 not supported by dual_kawase method, "
+			         "capping to 20.");
+			opt->blur_strength = 20;
+		}
+	}
+
 	if (opt->resize_damage < 0) {
 		log_warn("Negative --resize-damage will not work correctly.");
 	}
diff --git a/src/picom.c b/src/picom.c
index fd84081..7bc9816 100644
--- a/src/picom.c
+++ b/src/picom.c
@@ -459,6 +459,7 @@ static bool initialize_blur(session_t *ps) {
 	struct kernel_blur_args kargs;
 	struct gaussian_blur_args gargs;
 	struct box_blur_args bargs;
+	struct dual_kawase_blur_args dkargs;
 
 	void *args = NULL;
 	switch (ps->o.blur_method) {
@@ -476,6 +477,11 @@ static bool initialize_blur(session_t *ps) {
 		gargs.deviation = ps->o.blur_deviation;
 		args = (void *)&gargs;
 		break;
+	case BLUR_METHOD_DUAL_KAWASE:
+		dkargs.size = ps->o.blur_radius;
+		dkargs.strength = ps->o.blur_strength;
+		args = (void *)&dkargs;
+		break;
 	default: return true;
 	}
 
