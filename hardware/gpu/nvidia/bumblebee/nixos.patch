diff --git a/conf/xorg.conf.nouveau b/conf/xorg.conf.nouveau
index 87e48cb..2fc03ad 100644
--- a/conf/xorg.conf.nouveau
+++ b/conf/xorg.conf.nouveau
@@ -15,4 +15,5 @@ Section "Device"
 #   This Setting is needed on Ubuntu 13.04.
 #   BusID "PCI:01:00:0"
 
+    @nouveauDeviceOptions@
 EndSection
diff --git a/conf/xorg.conf.nvidia b/conf/xorg.conf.nvidia
index 5bd686e..5dc78e2 100644
--- a/conf/xorg.conf.nvidia
+++ b/conf/xorg.conf.nvidia
@@ -29,9 +29,8 @@ Section "Device"
     Option "ProbeAllGpus" "false"
 
     Option "NoLogo" "true"
-    Option "UseEDID" "false"
-    Option "UseDisplayDevice" "none"
 
+    @nvidiaDeviceOptions@
 #   If your NVIDIA drivers are version 331.13 or newer, and you have a laptop
 #   where some of the video outputs such as HDMI or DisplayPort are connected
 #   to the NVIDIA GPU, and you sometimes connect an external monitor to those
diff --git a/src/bbsecondary.c b/src/bbsecondary.c
index 21b1e35..fb257a8 100644
--- a/src/bbsecondary.c
+++ b/src/bbsecondary.c
@@ -145,6 +145,23 @@ bool start_secondary(bool need_secondary) {
     }
 
     bb_log(LOG_INFO, "Starting X server on display %s.\n", bb_config.x_display);
+    const char mod_appends[] = X_MODULE_APPENDS;
+
+    char *mod_path;
+    int pathlen = strlen(bb_config.mod_path);
+    if (pathlen == 0) {
+      mod_path = mod_appends;
+    } else {
+      mod_path = malloc(pathlen + 1 + sizeof(mod_appends));
+      if (!mod_path) {
+        set_bb_error("Could not allocate memory for modules path\n");
+        return false;
+      }
+      strcpy(mod_path, bb_config.mod_path);
+      mod_path[pathlen] = ',';
+      strcpy(mod_path + pathlen + 1, mod_appends);
+    }
+
     char *x_argv[] = {
       bb_config.xorg_binary,
       bb_config.x_display,
@@ -153,9 +170,10 @@ bool start_secondary(bool need_secondary) {
       "-sharevts",
       "-nolisten", "tcp",
       "-noreset",
+      "-logfile", "/var/log/X.bumblebee.log",
       "-verbose", "3",
       "-isolateDevice", pci_id,
-      "-modulepath", bb_config.mod_path, // keep last
+      "-modulepath", mod_path,
       NULL
     };
     char **argvp;
@@ -165,18 +183,17 @@ bool start_secondary(bool need_secondary) {
     }
     bb_log(LOG_DEBUG, "\n");
     enum {n_x_args = sizeof(x_argv) / sizeof(x_argv[0])};
-    if (!*bb_config.mod_path) {
-      x_argv[n_x_args - 3] = 0; //remove -modulepath if not set
-    }
     //close any previous pipe, if it (still) exists
     if (bb_status.x_pipe[0] != -1){close(bb_status.x_pipe[0]); bb_status.x_pipe[0] = -1;}
     if (bb_status.x_pipe[1] != -1){close(bb_status.x_pipe[1]); bb_status.x_pipe[1] = -1;}
     //create a new pipe
     if (pipe2(bb_status.x_pipe, O_NONBLOCK | O_CLOEXEC)){
       set_bb_error("Could not create output pipe for X");
+      if (pathlen > 0) free(mod_path);
       return false;
     }
     bb_status.x_pid = bb_run_fork_ld_redirect(x_argv, bb_config.ld_path, bb_status.x_pipe[1]);
+    if (pathlen > 0) free(mod_path);
     //close the end of the pipe that is not ours
     if (bb_status.x_pipe[1] != -1){close(bb_status.x_pipe[1]); bb_status.x_pipe[1] = -1;}
   }
diff --git a/src/optirun.c b/src/optirun.c
index a83b31d..810b9bf 100644
--- a/src/optirun.c
+++ b/src/optirun.c
@@ -221,7 +221,10 @@ static int run_primus(int argc, char **argv) {
   free(ldpath_new);
 
   /* set PRIMUS_libGLa */
-  char *libgl_mesa = "/usr/$LIB/libGL.so.1:/usr/lib/$LIB/libGL.so.1:/usr/$LIB/mesa/libGL.so.1:/usr/lib/$LIB/mesa/libGL.so.1";
+  char *libgl_mesa = malloc(strlen(bb_config.primus_ld_path) + sizeof("/libGL.so.1") + 1);
+
+  memcpy(libgl_mesa, bb_config.primus_ld_path, strlen(bb_config.primus_ld_path));
+  strcpy(libgl_mesa + strlen(bb_config.primus_ld_path), "/libGL.so.1");
   if (bb_config.ld_path[0]) { /* build new library path for PRIMUS_libGLa */
     int libgl_size = strlen(bb_config.ld_path) + 1;
     { /* calculate additional memories for adding "/libGL.so.1" */
@@ -258,6 +261,7 @@ static int run_primus(int argc, char **argv) {
 
   int exitcode = bb_run_fork(run_args, 0);
   free(run_args);
+  free(libgl_mesa);
   return exitcode;
 }
 
